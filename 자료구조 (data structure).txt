자료구조 (data structure)

Stack => 선형 자료구조, 후입 선출
push, pop, top => 자료 삽입, 제거, 반환

queue => 선형 자료구조, 선입 선출
ex) 프로세스 레디큐, 스케쥴링, 대기열이 있는 시스템
enqueue, dequeue, peekFront, peekRear

deque => stack + queue 느낌... 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조
=> 스택과 큐가 훨씬 유명하고 많이 쓰이는데 내 생각은 덱이 두개의 장점을
합쳐놓았다고 생각하는데 자주 쓰이지 않는 이유는 ? => 덱은 상수가 크다..
상수가 클 뿐만 아니라, 사용자의 행동제약 및 제공하는 역할이 단순화되서
제공해야할 것이 줄어들면, 조금 더 최적화시킬 수 있다.
스택을 예시로 들면 뜬금없는 원소가 추가되거나 삭제되는 상황에 대한 고려 X
이론상으로는 deque이 짱이지만, 실무에서는 stack/queue가 예외처리에 대하여
강하기 때문에, 사용자의 행동 제한. 라고 생각하면 될 듯

Tree => 노드로 이루어진 자료 구조. 사이클이 없는 그래프이며 계층적 자료를 표현

트리에서의 어려운 용어들 정리
차수 => 한 노드의 자식 개수
레벨 => 트리의 각 층에 번호를 매김. 루트가 1레벨
높이 => 트리가 가지고 있는 최대 레벨

특징 ) 간선의 개수는 정점의 개수 - 1
두 노드 간의 경로가 유일하고, 두개의 정점 사이에 반드시 1개의 경로를 가진다.

트리를 구현할 때 => 인접 배열 이용, 인접 리스트 이용 가능
인접 배열 -
1차원 배열 이용
트리는 부모 노드를 0개(root) 또는 1개를 가진다는 성질을 이용
배열 값에 부모노드의 번호를 저장한다.
2차원 배열 이용
이진 트리 구현시 2차원 배열에 자식 노드를 저장
a[i][0] : 왼쪽 자식 노드, a[i][1] : 오른쪽 자식 노드

이진트리 : 서브 트리는 공집합일 수 있고, 공집합도 이진 트리임.

포화 이진트리 ( full binary tree ) => 2 자식씩 꽉 찬 트리
완전 이진트리 ( complete binary tree ) -> 왼쪽부터 순차대로

트리의 순회

VLR ( preorder 전위 순회 )
루트, L, R 순서

LVR ( Inorder 중위 순회 )
L, 루트, R 순서

LRV ( postorder 후위 순회 )
L, R 루트 순서

LevelOrder 또한 있다. level 1=> 2, 3, 4순서

신장 트리
그래프 내의 모든 정점을 포함하는 트리
DFS, BFS 같은 탐색 알고리즘을 이용하여 그래프에서 신장 트리를 찾을 수 있다.

하나의 그래프에는 여러개의 신장 트리 존재할 수 있고, 사이클을 포함하지 않음.

모든 그래프의 간선이 같으면 모든 신장 트리가 최소 신장 트리이다.

Stack을 array로 구현한다면? => top pointer로 index 접근하면 돼서 속도가 빠르다.
크기가 한정적이다. 속도는 다 빠를 듯.

링크드리스트 => size같은 것을 구할 때 시간 복잡도가 O(N).

스택의 최대 크기를 확정적으로 알 수 있으면 array로, 모른다면
linkedlist로...

해싱?
해시테이블 : 키 값의 연산에 의해 직접 접근이 가능한 구조
해싱 : 해시테이블을 이용한 탐색
해시함수의 충돌과 해결책
리니어 프로빙 / 세퍼레이트 체이닝 등이 있을 듯
C++ STL중 unordered_map이 해시 테이블로 구현되어 있어 탐색이 매우 빠르다..
