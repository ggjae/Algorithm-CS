## algorithm

### Sort
Bubble Sort : 연속된 두 개 인덱스를 비교하여 조건에 맞게 위치를 바꾸는 정렬
시간 복잡도는 O(N^2), 공간 복잡도는 O(N). 현재 인덱스 값과 이전의 인덱스 값을 비교하며
교환을 진행한다.

Selection Sort : 맨 앞에서부터 하나씩 채워 나가기. 선택 정렬이라 함은 인덱스를 하나씩 선택하여
위치를 맞춰준다고 생각하면 좋을 듯. 이것 또한 O(N^2)

Insertion Sort : 내 앞에 있는 것과 계속 비교해서 위치 찾아 나가기.
마지막에 있는 값이 제일 많이 비교를 진행하게 됩니다.
정렬해야할 수가 적을 때 quick sort보다 빠른 성능을 나타내기도 함.
이미 정렬되어 있다면 O(N)이고, 공간 복잡도는 O(N)이다.
두번째 인덱스부터 시작함.

Merge Sort : 분할 정복 방식으로(divide and conquer)로 설계된 비교 기반 정렬
시간 복잡도는 O(Nlog N)이다. 하지만 공간복잡도 또한 O(Nlog N)이다.
한개의 길이로 된 리스트가 N개인 것으로 다 나눈 후에 다시 병합한다!
반으로 나누고.. 반으로 나누고.. 병합할 때 배열에 순서대로 담기게 됨.

Quick Sort : 분할 정복 방법에 근거한 이름 그대로 빠른 정렬.
최악의 경우엔 O(N^2) . 배열이 이미 정렬 or 역순 되어 있으면 오래 걸린다.
피봇 하나 잡아서 피봇보다 작으면 왼쪽, 크면 오른쪽으로 재배치함.
피봇을 나같은 경우에 중간값을 두기로 했었음. => 가장 왼쪽 값, 가장 오른쪽 값, 중앙 값
세가지 중 가운데 값을 사용했었던 것 같은데
개선하는 방법 : 1. pivot을 난수로 선택하기. => 확률에 맡기는 것이고
2. 삽입 정렬을 사용해서 개선하기. 추가적인 메모리가 필요 없기 때문에..
3. 세 값의 중위 값을 구한 퀵 정렬
가장 왼쪽 값, 오른쪽 값, 중간의 값을 구해서 세 값을 정렬한 다음에
중간 값을 가장 오른쪽값의 앞에다가 놓음 (a[right-1]) 정렬 범위에서
이미 정렬을 함으로써 깊이를 줄일 수 있다.

Topology Sort : 순서가 정해져 있는 작업을 진행할 때, 그 순서를 정하기 위해 사용하는 정렬
정렬의 결과가 여러가지 나올 수 있다. 시간의 복잡도는 O(V+E) : 정점의 개수 + 간선의 개수
진입차수가 0인 정점을 큐에 삽입 => 간선 제거하고, => 다시 degree를 낮춰준다.
모든 원소를 방문하기 전에 큐가 비었다면? => 사이클이 존재하는 것

Radix Sort : 1부터 100까지 있다.
10이상 20이하인 것 한 인덱스에 계속 박아놓고 => separate chanining 느낌 
실수에 대해 정렬하지 못함.
counting sort 의 업그레이드 버젼느낌이네. 많은 공간이 필요하다. O(dN) => d는 가장 긴 숫자의 자릿수

counting sort : 비교하지 않는 정렬. 값을 배열에 저장합니다.

kruskal : 탐욕적인 방법을 이용하여 최소 비용 신장 트리를 구축하는 알고리즘
=> union-find 기법이 들어간다. 간선을 가중치 순으로 정렬하고
차례대로 선택하여 그래프가 cycle 이루는지 확인하여 이룬다면 간선을 선택하지 않는 방법
union-find : 양 끝 정점이 같은 집합에 속해 있는지 검사
O(Elog E)의 시간 복잡도가 소요 됩니다. 

